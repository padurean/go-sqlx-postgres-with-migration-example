package database

import (
	"fmt"
	"time"

	"github.com/padurean/go-sqlx-postgres-with-migration-example/internal/env"
)

const tblMigration = "migrations"

func getMigrationDDL() string {
	fullTbl := env.Global.DB.Schema + "." + tblMigration
	// IMPORTANT: any SQL that goes in here must be idempotent as we can't keep
	//            versioning for the migrations table itself
	return `
CREATE TABLE IF NOT EXISTS ` + fullTbl + ` (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created timestamp with time zone NOT NULL DEFAULT now(),
	entity character varying(255) NOT NULL,
	version integer NOT NULL,
  sql text NOT NULL
);
CREATE UNIQUE INDEX IF NOT EXISTS ` + tblMigration + `_entity_version_unique_idx ON ` +
		fullTbl + ` (entity, version);
CREATE INDEX IF NOT EXISTS ` + tblMigration + `_created_idx ON ` + fullTbl + ` (created);`
}

var migrationSQLInsert string
var migrationSQLSelectByID string
var migrationSQLSelectList string

func initMigrationDML() {
	fullTbl := env.Global.DB.Schema + "." + tblMigration
	migrationSQLInsert = `INSERT INTO ` + fullTbl + ` (entity, version, sql)
		VALUES (:entity, :version, :sql) RETURNING id`
	migrationSQLSelectByID = `SELECT * FROM ` + fullTbl + ` WHERE id=$1`
	migrationSQLSelectList = `SELECT * FROM ` + fullTbl + ` ORDER BY entity, version`
}

// Migration ...
type Migration struct {
	ID      uint64    `json:"-" db:"id"`
	Created time.Time `json:"-" db:"created"`
	Entity  string    `json:"entity" validate:"required" db:"entity"`
	Version uint32    `json:"version" validate:"required" db:"version"`
	SQL     string    `json:"sql" validate:"required" db:"sql"`
}

// Create ...
func (m *Migration) Create(db *DB) (*Migration, error) {
	var mm Migration
	if err := Upsert(db, migrationSQLInsert, migrationSQLSelectByID, m, &mm); err != nil {
		return nil, err
	}
	return &mm, nil
}

// List ...
func (m *Migration) List(db *DB) ([]*Migration, error) {
	ms := []*Migration{}
	rows, err := db.Queryx(migrationSQLSelectList)
	if err != nil {
		return ms, fmt.Errorf("error preparing db select: %v", err)
	}
	defer rows.Close()
	for rows.Next() {
		mm := Migration{}
		err := rows.StructScan(&mm)
		if err != nil {
			return ms, fmt.Errorf(
				"error scanning %s row to struct: %v", tblMigration, err)
		}
		ms = append(ms, &mm)
	}
	return ms, nil
}
