package database

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/jmoiron/sqlx"
	"github.com/padurean/go-sqlx-postgres-with-migration-example/internal/env"
)

const tblLedgerStats = "ledger_stats"

func getLedgerStatsMigrations() []*Migration {
	fullTbl := env.Global.DB.Schema + "." + tblLedgerStats
	return []*Migration{
		{
			Entity:  tblLedgerStats,
			Version: 1,
			SQL: `
CREATE TABLE IF NOT EXISTS ` + fullTbl + ` (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	created timestamp with time zone NOT NULL DEFAULT now(),
	ledger_id bigint,
	last_insertion_at timestamp with time zone,
	active_sources integer,
	number_of_entries numeric,
	lsm_size_in_bytes numeric,
	vlog_size_in_bytes numeric,
	total_size_in_bytes numeric,
	total_pending_writes numeric,
	tampered timestamp with time zone
);
CREATE INDEX IF NOT EXISTS ` + tblLedgerStats + `_created_idx ON ` + fullTbl + ` (created);
CREATE INDEX IF NOT EXISTS ` + tblLedgerStats + `_ledger_id_idx ON ` + fullTbl + ` (ledger_id);`,
		},
		{
			Entity:  tblLedgerStats,
			Version: 2,
			SQL: `
ALTER TABLE IF EXISTS ` + fullTbl + ` DROP COLUMN IF EXISTS lsm_size_in_bytes;
ALTER TABLE IF EXISTS ` + fullTbl + ` DROP COLUMN IF EXISTS vlog_size_in_bytes;
ALTER TABLE IF EXISTS ` + fullTbl + ` DROP COLUMN IF EXISTS total_pending_writes;`,
		},
		{
			Entity:  tblLedgerStats,
			Version: 3,
			SQL: `
ALTER TABLE IF EXISTS ` + fullTbl + ` ADD COLUMN IF NOT EXISTS updated timestamp with time zone;
CREATE INDEX IF NOT EXISTS ` + tblLedgerStats + `_updated_idx ON ` + fullTbl + ` (updated);`,
		},
	}
}

var (
	ledgerStatsSQLInsert                         string
	ledgerStatsSQLUpdate                         string
	ledgerStatsSQLSelectByID                     string
	ledgerStatsSQLSelectList                     string
	ledgerStatsSQLSelectListForLedger            string
	ledgerStatsSQLSelectListForLedgerAndInterval string
	ledgerStatsSQLDeleteOld                      string
)

func initLedgerStatsDML() {
	fullTbl := env.Global.DB.Schema + "." + tblLedgerStats
	ledgerStatsSQLInsert = `INSERT INTO ` + fullTbl + ` (ledger_id, last_insertion_at, active_sources, number_of_entries, total_size_in_bytes, tampered)
		VALUES (:ledger_id, :last_insertion_at, :active_sources, :number_of_entries, :total_size_in_bytes, :tampered) RETURNING id`
	ledgerStatsSQLUpdate = `UPDATE ` + fullTbl +
		` SET ledger_id=:ledger_id, last_insertion_at=:last_insertion_at, active_sources=:active_sources, number_of_entries=:number_of_entries, total_size_in_bytes=:total_size_in_bytes, tampered=:tampered, updated=NOW() WHERE id=:id RETURNING id`
	ledgerStatsSQLSelectByID = `SELECT * FROM ` + fullTbl + ` WHERE id=$1`
	ledgerStatsSQLSelectList = `SELECT * FROM ` + fullTbl + ` ORDER BY created DESC LIMIT $1 OFFSET $2`
	ledgerStatsSQLSelectListForLedger = `SELECT * FROM ` + fullTbl + ` WHERE ledger_id=$1 ORDER BY created DESC LIMIT $2 OFFSET $3`
	ledgerStatsSQLSelectListForLedgerAndInterval = `SELECT * FROM ` + fullTbl +
		` WHERE ledger_id=$1 AND created >= $2 AND created < $3 ORDER BY created ASC`
	ledgerStatsSQLDeleteOld = `DELETE FROM ` + fullTbl + ` WHERE created < $1 RETURNING id`
}

// LedgerStats ...
type LedgerStats struct {
	ID               uint64       `json:"id"`
	Created          time.Time    `json:"created"`
	Updated          sql.NullTime `json:"updated"`
	LedgerID         uint64       `json:"ledger_id" db:"ledger_id"`
	LastInsertionAt  sql.NullTime `json:"-" db:"last_insertion_at"`
	ActiveSources    int          `json:"active_sources" db:"active_sources"`
	NumberOfEntries  uint64       `json:"number_of_entries" db:"number_of_entries"`
	TotalSizeInBytes uint64       `json:"total_size_in_bytes" db:"total_size_in_bytes"`
	Tampered         sql.NullTime `json:"-" db:"tampered"`
}

// Create ...
func (l *LedgerStats) Create(db *DB) (*LedgerStats, error) {
	return l.upsert(db, ledgerStatsSQLInsert)
}

// Update ...
func (l *LedgerStats) Update(db *DB) (*LedgerStats, error) {
	return l.upsert(db, ledgerStatsSQLUpdate)
}

func (l *LedgerStats) upsert(db *DB, sql string) (*LedgerStats, error) {
	var ll LedgerStats
	if err := Upsert(db, sql, ledgerStatsSQLSelectByID, l, &ll); err != nil {
		return nil, err
	}
	return &ll, nil
}

// GetByID ...
func (l *LedgerStats) GetByID(db *DB) (*LedgerStats, error) {
	var ll LedgerStats
	if err := SelectOne(db, ledgerStatsSQLSelectByID, l.ID, &ll); err != nil {
		return nil, err
	}
	return &ll, nil
}

// List ...
func (l *LedgerStats) List(db *DB, limit int, offset int) ([]*LedgerStats, error) {
	ls := []*LedgerStats{}
	var err error
	var lsRows *sqlx.Rows
	var q string
	switch {
	case l.LedgerID > 0:
		q = ledgerStatsSQLSelectListForLedger
		lsRows, err = db.Queryx(q, l.LedgerID, limit, offset)
	default:
		q = ledgerStatsSQLSelectList
		lsRows, err = db.Queryx(q, limit, offset)
	}
	if err != nil {
		return ls, fmt.Errorf("error preparing or executing db query '%s': %v", q, err)
	}
	defer lsRows.Close()
	for lsRows.Next() {
		ll := LedgerStats{}
		err := lsRows.StructScan(&ll)
		if err != nil {
			return ls, fmt.Errorf("error scanning ledger stats row to struct: %v", err)
		}
		ls = append(ls, &ll)
	}
	err = lsRows.Close()
	if err != nil {
		return ls, fmt.Errorf("error closing rows: %v", err)
	}
	return ls, nil
}

// ListForLedgerAndInterval fetches stats for the specified ledger created "since"
// (inclusive) until "before" (exclusive), order by creation date (ascending).
func (l *LedgerStats) ListForLedgerAndInterval(
	db *DB,
	since time.Time,
	before time.Time,
) ([]*LedgerStats, error) {
	q := ledgerStatsSQLSelectListForLedgerAndInterval
	lsRows, err := db.Queryx(q, l.LedgerID, since, before)
	if err != nil {
		return nil, fmt.Errorf("error preparing or executing db query '%s': %v", q, err)
	}
	defer lsRows.Close()
	ls := []*LedgerStats{}
	for lsRows.Next() {
		ll := LedgerStats{}
		err := lsRows.StructScan(&ll)
		if err != nil {
			return ls, fmt.Errorf("error scanning ledger stats row to struct: %v", err)
		}
		ls = append(ls, &ll)
	}
	return ls, nil
}

// DeleteOld ...
func (l *LedgerStats) DeleteOld(db *DB, olderThan time.Time) (int64, error) {
	return DeleteMany(db, ledgerStatsSQLDeleteOld, olderThan)
}
